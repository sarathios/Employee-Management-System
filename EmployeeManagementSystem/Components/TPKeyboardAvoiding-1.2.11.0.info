{"Name":"TPKeyboardAvoiding","Id":2488,"Alias":"TPKeyboardAvoiding","Description":"\n\u003ciframe src=\"https://appetize.io/embed/zafeap5j0bugwk5pm74kauat38?device=iphone5s\u0026scale=75\u0026autoplay=true\u0026orientation=portrait\u0026deviceColor=black\" \n        width=\"274px\" height=\"587px\" frameborder=\"0\" scrolling=\"no\"\n        style=\"float:right;margin-left:1em;\"\u003e\u0026nbsp;\u003c/iframe\u003e\n\n**TPKeyboardAvoiding** is a relatively universal, drop-in solution: `UIScrollView`, \n`UITableView` and `UICollectionView` subclasses that handle everything. \n\n## Features\n\nWhen the keyboard is about to appear, the subclass will find the subview that\u0027s about to be \nedited, and adjust its frame and content offset to make sure that view is visible, \nwith an animation to match the keyboard pop-up. \n\nWhen the keyboard disappears, it restores its prior size.\n\nIt also automatically hooks up \"Next\" buttons on the keyboard to switch through the text fields.\n\n## Usage\n\nTPKeyboardAvoiding should work with basically any setup, either a `UITableView`-based \ninterface, or one consisting of views placed manually.\n\nFor non-`UITableViewController`s, use it as-is by popping a `UIScrollView` into your view \ncontroller’s interface file, setting the class to `TPKeyboardAvoidingScrollView`, and \nputting all your controls within that scroll view.\n\nTo use it with `UITableViewController` just make your `UITableView` a \n`TPKeyboardAvoidingTableView` in the interface file — everything should be taken care of.\n\nTo disable the automatic \"Next\" button functionality, change the `UITextField`\u0027s return \nkey type to anything but `UIReturnKeyType.Default`.\n\n## Notes\n\nThese classes currently adjust the `ContentInset` parameter to avoid content moving beneath \nthe keyboard. \n\nThis is done, as opposed to adjusting the frame, in order to work around an \niOS bug that results in a jerky animation where the view jumps upwards, before settling \ndown. In order to facilitate this workaround, the `ContentSize` is maintained to be at \nleast same size as the view\u0027s frame.\n\n## Why TPKeyboardAvoiding?\n\nThere are a hundred and one proposed solutions out there for how to move `UITextField`\nand `UITextView` out of the way of the keyboard during editing — usually, it comes down \nto observing `UIKeyboardWillShowNotification` and `UIKeyboardWillHideNotification`, or \nimplementing `UITextFieldDelegate` delegate methods, and adjusting the frame of the \nsuperview, or using `UITableView`‘s `ScrollToRow()` method, but all the proposed \nsolutions I’ve found tend to be quite DIY, and have to be implemented for each view \ncontroller that needs it.\n","Version":"1.2.11.0","Summary":"A drop-in universal solution for moving text fields out of the way of the keyboard in iOS.","QuickStart":"\n**TPKeyboardAvoiding** is a relatively universal, drop-in solution: `UIScrollView`, \n`UITableView` and `UICollectionView` subclasses that handle everything. \n\n## Features\n\nWhen the keyboard is about to appear, the subclass will find the subview that\u0027s about to be \nedited, and adjust its frame and content offset to make sure that view is visible, \nwith an animation to match the keyboard pop-up. \n\nWhen the keyboard disappears, it restores its prior size.\n\nIt also automatically hooks up \"Next\" buttons on the keyboard to switch through the text fields.\n\n## Usage\n\nTPKeyboardAvoiding should work with basically any setup, either a `UITableView`-based \ninterface, or one consisting of views placed manually.\n\nFor non-`UITableViewController`s, use it as-is by popping a `UIScrollView` into your view \ncontroller’s interface file, setting the class to `TPKeyboardAvoidingScrollView`, and \nputting all your controls within that scroll view.\n\nTo use it with `UITableViewController` just make your `UITableView` a \n`TPKeyboardAvoidingTableView` in the interface file — everything should be taken care of.\n\nTo disable the automatic \"Next\" button functionality, change the `UITextField`\u0027s return \nkey type to anything but `UIReturnKeyType.Default`.\n\n## Notes\n\nThese classes currently adjust the `ContentInset` parameter to avoid content moving beneath \nthe keyboard. \n\nThis is done, as opposed to adjusting the frame, in order to work around an \niOS bug that results in a jerky animation where the view jumps upwards, before settling \ndown. In order to facilitate this workaround, the `ContentSize` is maintained to be at \nleast same size as the view\u0027s frame.\n\n## Why TPKeyboardAvoiding?\n\nThere are a hundred and one proposed solutions out there for how to move `UITextField`\nand `UITextView` out of the way of the keyboard during editing — usually, it comes down \nto observing `UIKeyboardWillShowNotification` and `UIKeyboardWillHideNotification`, or \nimplementing `UITextFieldDelegate` delegate methods, and adjusting the frame of the \nsuperview, or using `UITableView`‘s `ScrollToRow()` method, but all the proposed \nsolutions I’ve found tend to be quite DIY, and have to be implemented for each view \ncontroller that needs it.\n","Hash":"7b122910b6624bb3f7a739a145705798","TargetPlatforms":["ios"],"TrialHash":null}